\documentclass[a4paper,10pt]{article}

\input{packages.tex}
\input{configs.tex}

\title{Prova 1}

\begin{document}

\maketitle

\emergencystretch 3em

\input{recommendations.tex}

NOME: \rule{.85\textwidth}{0.1mm}

\begin{multicols*}{2}
\setlength{\leftmargini}{0pt}
\begin{enumerate}
  \item (1,0 pt) Verdadeiro ou falso.

  \begin{enumerate}

    % SOURCES
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 6.7
    \item Para acessar um elemento em um array, especificamos o nome do array e o valor do elemento em particular.
    % Falso, especificamos o nome do array e o índice do elemento
    \item Uma definição de array reserva espaço na memória para o array.
    % Verdadeiro
    \item Para indicar que 100 locais devem ser reservados para o array de inteiros \textbf{p}, escreva \textbf{p[100]};
    % Verdadeiro
    \item Um programa que inicializa os elementos de um array de 15 elementos com valor 0 precisa conter um laço \textbf{for}.
    % Falso, a incialização pode ser feita na declaração do array sem a utilização de um laço for

    % SOURCES
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 10.2

    \item Estruturas devem conter variáveis com apenas um tipo de dados.
    % Falso, estruturas podem conter variáveis com vários tipos de dados diferentes
    \item O nome de uma estrutura \textbf{struct nome \{ ... \};} é opcional.
    % Verdadeiro
    \item Os campos de diferentes estruturas devem ter nomes também diferentes.
    % Falso, estruturas diferentes podem ter campos com o mesmo nome
    \item A palavra-chave \textbf{typedef} é usada para definir novos tipos de dados.
    % Falso, a palavra-chave typedef é usada para definir sinônimos para tipos já existentes
    \item As estruturas são sempre passadas por referência para funções.
    % Falso, estruturas também podem ser passadas por valor

    % SOURCES
    % -
    \item O operador * retorna o local na memória em que seu operando está armazenado.
    % Falso, o operador * retorna o conteúdo associado ao endereço para o qual o seu operando aponta e não o próprio endereço. O operador que retorna o local na memória é o \&
  \end{enumerate}

  % \pagebreak

  \item (2,4 pt) Escreva instruções que executem as tarefas abaixo.

  \begin{enumerate}

    % SOURCES
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 4th Edition - Exercise 6.8
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 6.8
    \item Imprimir na tela o valor do 7º elemento do array de caracteres \textbf{f}.
    % printf("%c", f[6]);

    % \item Ler do teclado um valor no elemento de índice 4 do array de ponto flutuante \textbf{b}.
    % \item Inicializar cada um dos 5 elementos do array de inteiros \textbf{g} com o valor 8.
    % \item Somar os elementos do array de ponto flutuante \textbf{c} de 100 elementos.
    \item Copiar o array \textbf{a} na primeira parte do array \textbf{b}. Considere a declaração \textbf{double a[11], b[34];}
    % int i;
    % for(i = 0; i < 11; i++)
    %   b[i] = a[i];

    % \item Determinar e imprimir o menor e o maior valores contidos no array de ponto flutuante com 99 elementos \textbf{w}.

    % SOURCES
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 4th Edition - Exercise 6.12
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 6.12
    % \item Inicializar os 10 elementos do array de inteiros \textbf{contadores} com zeros.
    % \item Somar 1 a cada um dos 15 elementos do array de inteiros \textbf{bonus}.
    \item Ler do teclado os 12 valores do array de ponto flutuante \textbf{temp\_por\_mes}.
    % int i;
    % for(i = 0; i < 12; i++)
    %   scanf("%f", &temp_por_mes[i]);

    % \item Imprimir os cinco valores do array de inteiros \textbf{melhores\_placares} em formato de coluna.

    % SOURCES
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 8.2
    % \item Inicializar a string \textbf{u} com o valor \textbf{"ufal"} de \textbf{duas formas diferentes}.
    \item Inicializar a string \textbf{u} com o valor \textbf{"ufal"}.
    % char u[5] = "ufal";
    % char u[5] = {'u', 'f', 'a', 'l', '\0'}; (ALTERNATIVA)

    % SOURCES
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 8.33
    \item Determinar o comprimento de uma string \textbf{s}.
    % int comprimento;
    % comprimento = strlen(s);
    %
    % ALTERNATIVA:
    % int comprimento;
    % int i;
    % comprimento = 0;
    % for(i = 0; s[i] != '\0'; i++)
    %   comprimento++;

    % SOURCES
    % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 10.3
    \item Definir uma estrutura chamada \textbf{ferramenta} que contenha a variável \textbf{int numero\_ferramenta} e a string \textbf{nome\_ferramenta} de até 25 caracteres (o `\textbackslash0' não está incluso na contagem dos caracteres).
    % struct ferramenta {
    %   int numero_ferramenta;
    %   char nome_ferramenta[26];
    % };

    \item Definir \textbf{Ferramenta} como um sinônimo do tipo \textbf{struct ferramenta}.
    % typedef struct ferramenta Ferramenta;

    \item Usar \textbf{Ferramenta} para declarar a variável \textbf{a} e o array \textbf{b{[}10{]}}, ambos do tipo \textbf{struct ferramenta}, e a variável \textbf{ptr} do tipo ponteiro para \textbf{struct ferramenta}.
    % Ferramenta a, b[10], *ptr;

    \item Ler do teclado um número de ferramenta e um nome de ferramenta para os campos da variável \textbf{a}.
    % scanf("%d", &a.numero_ferramenta);
    % scanf("%s", a.nome_ferramenta);

    \item Atribuir os valores dos campos da variável \textbf{a} ao elemento de índice 3 do array \textbf{b}.
    % b[3] = a;
    %
    % ALTERNATIVA:
    % int i;
    % b[3].numero_ferramenta = a.numero_ferramenta;
    % for (i = 0; a.nome_ferramenta[i] != '\0'; i++)
    %   b[3].nome_ferramenta[i] = a.nome_ferramenta[i];

    \item Atribuir o endereço do array \textbf{b} ao ponteiro \textbf{ptr}.
    % ptr = b;

    \item Imprimir os valores dos campos do elemento de índice 3 do array \textbf{b} usando a variável \textbf{ptr} e o operador de ponteiro da estrutura (->).
    % printf("%d\n", (ptr + 3)->numero_ferramenta);
    % printf("%s\n", (ptr + 3)->nome_ferramenta);

  \end{enumerate}

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 5.5
  \item (0,8 pt) Dê o \textbf{protótipo de função} para cada um dos seguintes itens:

    \begin{enumerate}
      \item Função \textbf{hipotenusa}, que utiliza dois argumentos de ponto flutuante, \textbf{lado1} e \textbf{lado2}, e retorna um resultado de ponto flutuante.
      % float hipotenusa(float lado1, float lado2);

      \item Função \textbf{minimo}, que utiliza três inteiros, \textbf{x}, \textbf{y}, \textbf{z}, e retorna um inteiro.
      % int minimo(int x, int y, int z);

      \item Função \textbf{instrucoes}, que não recebe argumento algum e não retorna um valor.
      % void instrucoes(void);

      \item Função \textbf{intParaFloat}, que utiliza um argumento inteiro, \textbf{number}, e retorna um resultado de ponto flutuante.
      % float intParaFloat(int number);
    \end{enumerate}

  \vfill\null
  \pagebreak
  \vspace*{0.0cm}

  \item (2,2 pt) Explique o(s) problema(s) nos fragmentos de código abaixo

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 4th Edition - Exercise 6.13
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 6.13
%   \begin{minted}[label=\textnormal{\footnotesize(a) \textbf{{[}arrays, strings{]}}}]{c}
% char str[3];
% scanf("%s", str);
% /* Usuário digita olá */
%   \end{minted}

  \begin{minted}[label=\textnormal{\footnotesize(a) \textbf{{[}arrays{]}}}]{c}
int a[3];
printf("$d %d %d\n", a[1], a[2], a[3]);
  \end{minted}
  % Deveria ser um símbolo \% ao invés de um \$ no primeiro argumento do printf e os índices do array a deveriam ir de 0 a 2 e não de 1 a 3.

  \begin{minted}[label=\textnormal{\footnotesize(b) \textbf{{[}arrays{]}}}]{c}
double f[3] = {1.1, 2.2, 3.3, 4.4};
  \end{minted}
  % O array é inicializado com mais elementos do que ele pode guardar.

  \begin{minted}[label=\textnormal{\footnotesize(c) \textbf{{[}arrays{]}}}]{c}
double d[2][10];
d[1, 9] = 2.345;
  \end{minted}
  % O formato de acesso do array está errado, deveria ser d[1][9].

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 8.4
  \begin{minted}[label=\textnormal{\footnotesize(d) \textbf{{[}strings{]}}}]{c}
printf("%s", 'a');
  \end{minted}
  % Um elemento entre aspas simples é um caractere e não uma string. Deveria ser ou ``\%c'' no primeiro argumento ou ``a'' no segundo argumento do printf.

  \begin{minted}[label=\textnormal{\footnotesize(e) \textbf{{[}strings{]}}}]{c}
char s[12];
strcpy(s, "Seja bem-vindo, visitante!");
  \end{minted}
  % A string que está sendo copiada em s é maior do que ela pode guardar.

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 10.4
  \begin{minted}[label=\textnormal{\footnotesize(f) \textbf{{[}tipos def. pelo prog.{]}}}]{c}
struct pessoa {
  char nome[15];
  char sobrenome[15];
  int idade;
}
pessoa d;
  \end{minted}
  % Faltam: 1) um ponto-e-vírgula no final da declaração da struct; 2) a palavra struct no início da declaração da variável d.

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 5.7
  \begin{minted}[label=\textnormal{\footnotesize(g) \textbf{{[}funções{]}}}]{c}
int g(void) {
  printf("Dentro da função g\n");

  int h(void) {
    printf("Dentro da função h\n");
  }
}
  \end{minted}
  % Uma função não pode ser definida dentro de outra função.

  \begin{minted}[label=\textnormal{\footnotesize(h) \textbf{{[}funções{]}}}]{c}
int soma(int x, int y) {
  int resultado;
  resultado = x + y;
}
  \end{minted}
  % A função deveria retornar um valor.

  \begin{minted}[label=\footnotesize(i) \textbf{{[}ponteiros{]}}]{c}
int *x;
int y;

x = y;
  \end{minted}
  % A variável x é um ponteiro, ela precisa receber o endereço da variável y com o operador \& (x = \&y). Outra possibilidade de solução seria a declaração de x como uma variável normal e não um ponteiro, removendo o operador *.

  \begin{minted}[label=\textnormal{\footnotesize(j) \textbf{{[}funções{]}}}]{c}
void produto(void) {
  int a, b, c, resultado;
  printf("Digite três inteiros: ")
  scanf("%d %d %d", &a, &b, &c);
  resultado = a * b * c;
  printf("Resultado é %d", resultado);
  return resultado;
}
  \end{minted}
  % A função não deveria retornar um resultado e falta um ponto-e-vírgula depois do printf.

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 4th Edition - Exercise 5.50
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 5.46
  \begin{minted}[label=\textnormal{\footnotesize(k) \textbf{{[}funções, recursão{]}}}]{c}
int soma(int n) {
  if (n == 0)
    return 0;
  else
    return n + soma(n);
}
  \end{minted}
  % A chamada recursiva da função soma não atualiza o argumento (deveria ser n - 1), de forma que a função nunca chega no critério de parada (n == 0) e fica presa em um laço infinito.

  \vfill\null
  \columnbreak
  \vspace*{0.0cm}

  \item (3,6 pt) O que os programas abaixo fazem? E o que eles imprimem na tela?

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 4th Edition - Exercise 6.17
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 6.17
  \begin{minted}[label=\textnormal{\footnotesize(a) \textbf{{[}arrays, recursão{]}}}]{c}
#include <stdio.h>

int funcao(int *b, int p) {
  if (p == 1)
    return b[0];
  else
    return b[p - 1] + funcao(b, p - 1);
}

int main() {
  int x;
  int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  x = funcao(a, 10);
  printf("O resultado é %d\n", x);
  return 0;
}
  \end{minted}
  % A função retorna o somatório de todos os elementos do array que é passado para ela. O programa imprime na tela: "O resultado é 55".

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 4th Edition - Exercise 6.18
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 6.18
%   \begin{minted}[label=\textnormal{\footnotesize(b) \textbf{{[}arrays, recursão{]}}}]{c}
% #include <stdio.h>

% void funcao(int *b, int indice_inicial, int tamanho) {
%   if (indice_inicial < tamanho) {
%     funcao(b, indice_inicial + 1, tamanho);
%     printf("%d  ", b[indice_inicial]);
%   }
% }

% int main() {
%   int a[10] = {8, 3, 1, 2, 6, 0, 9, 7, 4, 5};

%   printf("Resposta:\n");
%   funcao(a, 0, 10);
%   printf("\n");

%   return 0;
% }
%   \end{minted}

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 8.3
  \begin{minted}[label=\textnormal{\footnotesize(b) \textbf{{[}strings{]}}}]{c}
#include <string.h>

int main() {
  char s1[50] = "ufal";
  char s2[50] = "penedo";
  char s3[50];

  strcpy(s3, s1);
  strcat(s3, "_em_");
  strcat(s3, s2);

  printf("%d", strlen(s1) + strlen(s2));
  printf("%s", s3);
  printf("%d", strlen(s3));
}
  \end{minted}
  % O programa copia o valor de s1 para s3, depois concatena a string ``\_em\_'' com s3, e depois concatena s2 com s3, de forma que s3 fica com o valor ``ufal\_em\_penedo''. Ele imprime na tela os tamanhos de s1 e s2 somados (10), s3 (ufal\_em\_penedo) e o tamanho de s3 (14).

%   % SOURCES
%   % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 4th Edition - Exercise 5.47
%   % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 5.43
%   \begin{minted}[label=\textnormal{\footnotesize(c) \textbf{{[}funções, recursão{]}}}]{c}
% #include <stdio.h>

% int funcao(int a, int b) {
%   // Parâmetro b deve ser um inteiro positivo,
%   // para impedir recursão infinita

%   if (b == 1) {
%     return a;
%   } else {
%     return a + funcao(a, b - 1);
%   }
% }

% int main(void) {
%   int x;
%   int y;

%   printf("Digite dois inteiros: ");
%   scanf("%d %d", &x, &y);
%   printf("O resultado é %d\n", funcao(x, y));
%   return 0;
% }
%   \end{minted}

  % SOURCES
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 4th Edition - Exercise 7.30
  % - DEITEL, H. M.; DEITEL, P. J. C: How to Program, 6th Edition - Exercise 7.26
  \begin{minted}[label=\textnormal{\footnotesize(c) \textbf{{[}strings, ponteiros{]}}}]{c}
#include <stdio.h>

int funcao(char *s1, char *s2) {
  while (*s1 != '\0' && *s2 != '\0') {
    if (*s1 != *s2) {
      return 0;
    }
    s1++;
    s2++;
  }
  return 1;
}

int main() {
  char str1[80];
  char str2[80];
  int r;
  printf("Digite duas strings: ");
  scanf("%s%s", str1 , str2);

  r = funcao(str1, str2);
  printf("O resultado é %d\n", r);
  return 0;
}
  \end{minted}
  % A função compara duas strings (a partir do início) usando aritmética de ponteiros e retorna 1 se elas forem iguais (até o ponto onde uma delas acaba) e 0 se elas forem diferentes. Dessa forma, a função retorna 1 tanto quando as strings forem exatamente iguais, quanto se uma delas estiver no início da outra. A impressão na tela depende da entrada do usuário no teclado. Exemplos: str1 = ``thiago'', str2 = ``ufal'', resultado = 0; str1 = ``ufal'', str2 = ``ufal'', resultado = 1; str1 = ``ufal'', str2 = ``ufal12345'', resultado = 1.
\end{enumerate}
\end{multicols*}
\end{document}
