\documentclass[a4paper,10pt]{article}

\input{packages.tex}
\input{configs.tex}

\title{Prova 2}

\begin{document}

\maketitle

\emergencystretch 3em

\input{recommendations.tex}

NOME: \rule{.85\textwidth}{0.1mm}

\begin{multicols*}{2}
\setlength{\leftmargini}{0pt}
\begin{enumerate}
  \item (2,8 pt $\rightarrow$ 7 x 0,4 pt) Preencha os espaços:

  \begin{enumerate}
    % \item A função \rule{1cm}{0.2mm} grava uma string em um arquivo. % fputs
    \item A função \rule{1cm}{0.2mm} é usada na liberação da memória alocada dinamicamente para um elemento de uma lista encadeada. % free
    \item A função \rule{1cm}{0.2mm} move a posição atual de leitura/escrita no arquivo para o início. % rewind
    \item A função \rule{1cm}{0.2mm} grava um caractere em um arquivo. % fputc
    \item A função \rule{1cm}{0.2mm} lê uma string de um arquivo. % fgets
    % \item A função \rule{1cm}{0.2mm} lê dados de um arquivo da mesma forma que a função \texttt{scanf} lê do teclado. % fscanf
    % \item A função \rule{1cm}{0.2mm} move a posição atual de leitura/escrita no arquivo para um ponto específico. % fseek
    % \item A função \rule{1cm}{0.2mm} fecha um arquivo. % fclose
    \item A função \rule{1cm}{0.2mm} é usada para alocar dinamicamente um novo elemento de uma lista encadeada. % malloc
    \item A função \rule{1cm}{0.2mm} geralmente é usada para gravar blocos de bytes em um arquivo binário. % fwrite
    \item A função \rule{1cm}{0.2mm} abre um arquivo. % fopen
    % \item A função \rule{1cm}{0.2mm} lê um caractere de um arquivo. % fgetc
    % \item A função \rule{1cm}{0.2mm} normalmente é usada quando se lê blocos de bytes de um arquivo binário. % fread
  \end{enumerate}

  \item (2,1 pt $\rightarrow$ 3 x 0,7 pt) Verdadeiro ou falso. Justifique sua resposta para afirmações falsas.

  \begin{enumerate}
    % \item Se a posição atual de leitura/escrita no arquivo não estiver no início, o arquivo precisa ser fechado e reaberto para que a leitura possa ser feita a partir do início. % Falso. A função rewind pode ser usada para mover a posição para o início.
    \item A função \texttt{fprintf} pode imprimir os dados na tela. % Verdadeiro
    \item A função \texttt{fscanf} não pode ser usada para ler dados do teclado. % Falso. Pode ser usada para ler dados do teclado usando o ponteiro para o arquivo stdin.
    \item A função \texttt{fseek} só pode fazer a busca a partir do início de um arquivo. % Falso. Pode fazer a busca a partir do início, do fim ou da posição atual.
  \end{enumerate}

  \item (2,0 pt $\rightarrow$ 2 x 1,0 pt) Escreva o código para completar as tarefas a seguir:
  % FILE* arq1;
  % FILE* arq2;
  %
  % arq1 = fopen("arquivo1.txt", "r");
  % arq2 = fopen("arquivo2.txt", "a");
  %
  % primeiro_char = fgetc(arq1);
  % fprintf("int %d", sizeof(int));

  \begin{minted}{c}
#include <stdio.h>

int main () {
  char primeiro_char;
  // << SEU CÓDIGO ENTRA AQUI >>
  fclose(arq1);
  fclose(arq2);
}
  \end{minted}

  \begin{enumerate}
    \item Abra um arquivo chamado \texttt{"arquivo1.txt"}, em uma variável chamada \texttt{arq1}, no modo de leitura. Leia o primeiro caractere do arquivo em uma variável chamada \texttt{primeiro\_char}.
    % \item Abra um arquivo chamado \texttt{arquivo2.txt}, em uma variável chamada \texttt{arq2}, no modo de escrita em arquivo binário, de forma que o arquivo seja criado, caso não exista, ou apagado e escrito por cima, caso já exista.
    \item Abra um arquivo chamado \texttt{"arquivo2.txt"}, em uma variável chamada \texttt{arq2}, no modo de escrita, de forma que os dados sejam adicionados ao final do arquivo. Escreva no arquivo, com a função \texttt{fprintf}, a string \texttt{"int"} seguida de um espaço e o tamanho em bytes de um inteiro. Use a função \texttt{sizeof} para obter esse tamanho.
  \end{enumerate}

  \bigskip

  \item (3,1 pt) Leia o código abaixo e faça as tarefas:

  \begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

// DECLARAÇÃO DO ELEMENTO DA LISTA
struct lista {
  int dados;
  struct lista* prox;
};

// SINÔNIMO PARA STRUCT LISTA
typedef struct lista Lista;

// FUNÇÕES concatena_listas E media_lista
Lista* concatena_listas(Lista* l1, Lista* l2) {
  Lista* p;
  // << SEU CÓDIGO ENTRA AQUI >>
  return l1;
}

float media_lista(Lista* l) {
  Lista* p;
  int soma = 0;
  int contador = 0;
  // << SEU CÓDIGO ENTRA AQUI >>
  return (float) soma/contador;
}

int main () {
  int i;
  Lista* lst1, lst2;

  lst1 = cria_lista();
  lst2 = cria_lista();

  for(i = 1; i < 4; i++) {
    lst1 = insere_lista(lst1, i);
    lst2 = insere_lista(lst2, i + 6);
  }

  imprime_lista(lst1);
  printf("\n%f\n", media_lista(lst1));

  imprime_lista(lst2);
  printf("\n%f\n", media_lista(lst2));

  lst1 = concatena_listas(lst1, lst2);

  imprime_lista(lst1);
  printf("\n%f\n", media_lista(lst1));
}
  \end{minted}

  \begin{enumerate}
    \item (1,3 pt) Complete a função \texttt{concatena\_listas}, que deve inserir a lista \texttt{l2} no final da lista \texttt{l1}.
    % Lista* concatena(Lista* l1, Lista* l2) {
    %   Lista* p = l1;
    %
    %   while (p->prox != NULL) {
    %     p = p->prox;
    %   }
    %
    %   p->prox = l2;
    %
    %   return l1;
    % }
    \item (1,0 pt) Complete a função \texttt{media\_lista}, que calcula a média dos elementos em uma lista.
    % float media_lista(Lista* l) {
    %   Lista* p;
    %   int soma = 0;
    %   int contador = 0;
    %
    %   for(p = l; p != NULL; p = p->prox) {
    %     soma += p->dados;
    %     contador++;
    %   }
    %
    %   return (float) soma/contador;
    % }
    \item (0,8 pt) Escreva o que vai ser impresso na tela com a execução do programa.
    % 3 2 1
    % 2
    % 9 8 7
    % 8
    % 3 2 1 9 8 7
    % 5
  \end{enumerate}
\end{enumerate}
\end{multicols*}
\end{document}
